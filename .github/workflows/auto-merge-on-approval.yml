name: Auto-merge on approval

on:
  pull_request_review:
    types: [submitted]

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  merge:
    runs-on: ubuntu-latest
    if: ${{ github.event.review.state == 'approved' }}
    steps:
      - name: Approve workflow runs (maintainer only)
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const reviewer = context.payload.review?.user?.login;

            if (!pr || !reviewer) {
              core.info("Missing pull request or reviewer context.");
              return;
            }

            let permission = "none";
            try {
              const response = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: reviewer,
              });
              permission = response.data.permission;
            } catch (error) {
              core.warning(`Unable to resolve reviewer permission: ${error.message}`);
              return;
            }

            const allowed = new Set(["admin", "maintain", "write"]);
            if (!allowed.has(permission)) {
              core.info(`Reviewer ${reviewer} does not have maintainer permissions.`);
              return;
            }

            try {
              const runs = await github.rest.actions.listWorkflowRunsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                event: "pull_request",
                head_sha: pr.head.sha,
                per_page: 50,
              });

              const pending = runs.data.workflow_runs.filter((run) =>
                ["waiting", "action_required"].includes(run.status)
              );

              if (pending.length === 0) {
                core.info("No workflow runs awaiting approval.");
                return;
              }

              for (const run of pending) {
                try {
                  await github.request("POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve", {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.id,
                  });
                  core.info(`Approved workflow run ${run.id}.`);
                } catch (error) {
                  core.warning(`Unable to approve run ${run.id}: ${error.message}`);
                }
              }
            } catch (error) {
              core.warning(`Unable to list workflow runs: ${error.message}`);
            }
      - name: Merge pull request
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const reviewer = context.payload.review?.user?.login;

            if (!pr || pr.state !== "open") {
              core.info("Pull request is not open.");
              return;
            }

            if (pr.draft) {
              core.info("Pull request is draft.");
              return;
            }

            if (pr.merged) {
              core.info("Pull request already merged.");
              return;
            }

            // Check reviewer permissions
            if (!reviewer) {
              core.info("Missing reviewer context.");
              return;
            }

            let permission = "none";
            try {
              const response = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: reviewer,
              });
              permission = response.data.permission;
            } catch (error) {
              core.warning(`Unable to resolve reviewer permission: ${error.message}`);
              return;
            }

            const allowed = new Set(["admin", "maintain", "write"]);
            if (!allowed.has(permission)) {
              core.info(`Reviewer ${reviewer} does not have sufficient permissions to merge (requires write access or higher).`);
              return;
            }

            // Check required status checks
            try {
              const combinedStatus = await github.rest.repos.getCombinedStatusForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha,
              });

              // Get check runs as well (for Actions checks)
              const checkRuns = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha,
              });

              // Check if any status is failing or pending
              if (combinedStatus.data.state === "pending") {
                core.info("Required status checks are still pending.");
                return;
              }

              if (combinedStatus.data.state === "failure") {
                core.info("Required status checks have failed.");
                return;
              }

              // Check if any check runs are not successful
              const nonSuccessfulRuns = checkRuns.data.check_runs.filter(
                (run) => run.status !== "completed" || run.conclusion !== "success"
              );

              if (nonSuccessfulRuns.length > 0) {
                core.info(`Some check runs are not successful: ${nonSuccessfulRuns.map(r => r.name).join(", ")}`);
                return;
              }

            } catch (error) {
              core.warning(`Unable to check status: ${error.message}`);
              return;
            }

            // All checks passed, proceed with merge
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                merge_method: "merge",
              });
              core.info(`Successfully merged PR #${pr.number}`);
            } catch (error) {
              core.warning(`Merge failed: ${error.message}`);
            }
