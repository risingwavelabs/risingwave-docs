---
title: "Streaming optimizations"
description: "Learn about how to improve the performance of streaming queries by rewriting them using specific patterns."
---

This section covers best practices for optimizing streaming queries.
You can often achieve better performance by rewriting your SQL to follow certain recommended patterns.

## SQL optimizations

### UNION vs UNION ALL

UNION removes duplicates, while UNION ALL does not.
If you know that your data does not contain duplicates, use UNION ALL to avoid the overhead of duplicate removal.
Alternatively, if the duplicate set is small, you can also filter out duplicates when querying the result set.

### OverWindow vs GroupTopN

OverWindow is a streaming operator that maintains the state of the window and computes the row number for each row in the partition.

Queries look something like:
```sql
select *, row_number() over (PARTITION BY v1 order by v2) r from t3
```

This can be optimized by using the `GroupTopN` operator instead.

Checkout [Converting StreamOverWindow to StreamGroupTopN](/processing/sql/top-n-by-group#converting-streamoverwindow-to-streamgrouptopn) for more details.

## Join optimizations

Checkout [Join Optimizations](/processing/sql/joins#converting-dimension-table-joins-to-process-time-joins) for more details.

## State table memory preloading

*Premium feature available in RisingWave Cloud and Enterprise.*

### Syntax

Configure memory preloading in your `risingwave.toml` file:

```toml
[streaming.developer]
default_enable_mem_preload_state_table = true
mem_preload_state_table_ids_whitelist = [1001, 1002]
mem_preload_state_table_ids_blacklist = [2001]
```

Or use environment variable for global configuration:

```bash
export DEFAULT_ENABLE_MEM_PRELOAD_STATE_TABLE=true
```

### Parameters

| Parameter                               | Type         | Default | Notes                                                     |
| :-------------------------------------- | :----------- | :------ | :-------------------------------------------------------- |
| default\_enable\_mem\_preload\_state\_table | bool         | false   | Enable memory preloading for all state tables            |
| mem\_preload\_state\_table\_ids\_whitelist | int\[\]      | \[\]    | State table IDs to enable when global setting is false   |
| mem\_preload\_state\_table\_ids\_blacklist | int\[\]      | \[\]    | State table IDs to disable when global setting is true   |

### When to use

Enable memory preloading for:
- State tables with frequent random access patterns
- Tables that fit in available memory
- Workloads experiencing high cache miss rates

Monitor memory usage when enabling this feature.

### Examples

**Enable for all state tables:**

```toml
[streaming.developer]
default_enable_mem_preload_state_table = true
```

**Enable for specific tables only:**

```toml
[streaming.developer]
default_enable_mem_preload_state_table = false
mem_preload_state_table_ids_whitelist = [1001, 1002, 1003]
```

**Enable globally but exclude specific tables:**

```toml
[streaming.developer]
default_enable_mem_preload_state_table = true
mem_preload_state_table_ids_blacklist = [2001, 2002]
```

<Note>
Tables with non-primary-key prefix watermarks automatically disable memory preloading.
</Note>